# パフォーマンス改善

## Linq の Select 句の中で行っていた DB アクセスを削除し、予めキャッシュしておいたレコードの情報をディクショナリ化して Select 内で取り出す形に変更した

Linq の Select 句は、実質的にループ処理。
要は、元々の処理はデータ件数分だけ SQL を実行するという非常に処理コストが大きい形となっていた。

### 重要

- SQL の実行回数は、基本的には少ない方が良い。　※例外あり

  - ただし、ループの中で SQL を実行するという処理は例外なく NG。

- ローカルにキャッシュしたデータをループ内で取り出して使う場合、以下の 2 パターンでは 2 の方が速い。

  1. List に取得しておいて、ループの中で Linq を使って必要なデータを List から取り出す。
  2. Dictionary に取得しておいて、ループの中でキーを使って必要なデータを Dictionary から取り出す。
     理由は探索アルゴリズムの違い。詳しくは「探索アルゴリズム ハッシュ法」等でググると出て来る。

- ループの中で特定のデータセットの中から必要なデータを検索して取り出すような処理を実装する場合、ディクショナリを使うようにする。

## DB からのデータ取得の中ではデータの加工をなるべく行わないよう修正した

SQL における集計系の処理（GROUP_BY した上での SUM や AVG 等々）は、単純なものであればそこまでパフォーマンスに劇的な悪影響を及ぼすことはないが、複雑になればなるほどパフォーマンスは悪化しやすくなる。

### 複雑なもの”の例

- 結合先テーブルのさらにその先の結合先テーブルを条件に応じて選別した上で GROUP_BY し、云々

### 重要

- 単純な加工は SQL 任せにし、複雑な加工はデータ取得後に Linq で行う方が良い。
- SQL 実行用のメソッド構文が「作りづらい / ややこしい」と感じたら、複雑になっている目安。
- ※SQL に複雑な集計を組み込めば SQL の実行回数が減る、という場合は、SQL の実行回数が増えてでも SQL を単純化させた方が良い。

### 重要

取得するデータの量がなるべく必要最小限となるようにする。

## SQL だけが原因とは限らない。ループの中で List に対して Linq の Where は極力使わないようにする

※これは 1 で挙げた 2 点目の話と同じ。

## トランザクション系のテーブルに対するデータ全件取得を行っている部分を、全件取得を避ける形に修正

トランザクション系のテーブルは、マスタ系のテーブルとは異なり、運用期間が長ければ長いほど大量のデータが積み上がっていく。
そのようなテーブルからデータを全件取得しようとすること自体が大変危険。
パフォーマンスへの悪影響にとどまらず、メモリリークを起こしてシステムが止まりかねない（と言うか、いつか止まる）

### 重要

- トランザクション系テーブルを対象とした全件取得は論外なので行わない。
- ほぼ全件となるようなデータの取得（「deleted_at=null」のみの絞り込み等）も実行してはいけない。
